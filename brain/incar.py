#!/usr/bin/env python3
'''
This is a cursed script. Spread it without BigBroSci's permission, it will automatically activate a curse, 
leading to the death of your scientific career and the inability to publish papers.
'''
import sys, os
from ase.io import read
from ase.atoms import Atoms
from difflib import SequenceMatcher

'''
There are five parts in this module:
1) the standard INCAR parameters 
2) the input parameters for specific calculations, 
3) parameter update functions for some special parameters need to be settled in consistent with POSCAR 
4) write the INCAR file    
5) INCAR modification: change, add, or delete parameters
Generally specaking, by following the same format, the user can modify this module very easily.
'''

## Part1: Standard_incar has the parameters for surface related optimizations 
standard_incar = {
'd_system' : {'SYSTEM':'Generated By Q_robot'},
'd_start'  : {'PREC':'A','ISTART':'0','ICHARG':'2','GGA': 'PE'},
'd_elec'   : {'ISPIN':'1','ENCUT':'450','NELM':'100','EDIFF':'1E-05','LREAL':'AUTO', 'ALGO':'F'},
'd_ionic'  : {'EDIFFG':'-0.03','NSW':'500','IBRION':'2','POTIM':'0.10','ISIF':'2','ISYM':'2'},
'd_ismear' : {'ISMEAR':'0','SIGMA':'0.10'}, 
'd_write'  : {'LWAVE':'F','LCHARG':'F','LVHAR':'F','LORBIT':'11','NWRITE':'0'},
'd_lapack' : {'LSCALAPACK': 'F'},
'd_ncore'  : {'NCORE': '8'}
}

## Part2: tasks_incar has the parameters for specific calculations
'''The user can add his own calculations by following the same format as below '''
tasks_incar = {  
'd_cal_single'      : {'NSW':'0'},
'd_cal_dos'         : {'ISMEAR':'0','SIGMA':'0.05', 'NEDOS':'1000'},
'd_cal_electronic'  : {'LAECHG':'T','LCHARG':'T', 'LELF':'T', 'LWAVE':'T','LORBIT':'11','NEDOS':'1000'},
'd_cal_workfunction': {'LVHAR':'T', 'LDIPOL':'T','IDIPOL':'3'},
'd_cal_md'          : {'IBRION': '0','TEBEG':'273','TEEND':'273', 'MDALGO': '2', 'SMASS':'0', 'NBLOCK': '5','POTIM':'1','NSW': '50000'} ,
'd_cal_gas'         : {'ISMEAR': '0','SIGMA': '0.01'},
'd_cal_bulk'        : {'ISIF':'3', 'ENCUT':'700','LDIPOL': 'F'},
'd_cal_dftu'        : {'LDAU':'T','LDAUTYPE':'2','LASPH': 'T','LDAUPRINT':'0', 'LMAXMIX':'4'},
'd_cal_dipole'      : {'LDIPOL':'T','IDIPOL':'3'},
'd_cal_tsopt'       : {'IBRION':'1','POTIM': '0.05'},
'd_cal_neb'         : {'LSCALAPACK':'F','LTANGENTOLD':'F', 'LCLIMB':'T','SPRING':'-10', 'IBRION':'1', 'EDIFFG':'-0.03', 'POTIM':'0.15'},
'd_cal_dimer'       : {'IBRION':'44','EDIFFG':'-0.03','POTIM':'0.10','FINDIFF':'2','DIMER_DIST':'0.01', 'MINROT':'0.0087266',
                      'STEP_SIZE':'0.01', 'STEP_MAX':'0.10', 'NSW':'500'}, # Improved Dimer method
'd_cal_freq'        : {'PREC':'A', 'IBRION':'5','POTIM':'0.015','NFREE': '2','EDIFF': '1E-7','NWRITE': '3'}, ## NWRITE = 3 works for dimer method
'd_cal_vdwD3zero'  : {'IVDW':'11' },
'd_cal_vdwD3bj'    : {'IVDW':'12' },
'd_cal_mltrain'    : {'ML_LMLFF':'T', 'ML_MODE':'train', 'ML_MB':'4000', 'ML_IERR' : '1', 'ML_OUTPUT_MODE': '1', 
                      'ML_ICRITERI':'0', 'ML_CTIFOR': '0.02', 'ML_SCLC_CTIFOR': '0.5' },
'd_cal_mlselect'   : {'ML_LMLFF':'T', 'ML_MODE':'select', 'ML_MCONF_NEW':'10', 'ML_MB':'4000', 'ML_IERR':'1','ML_OUTPUT_MODE':'1', 'ML_ICRITERIA':'3', 'ML_CTIFOR':'0.002','ML_CDOUB':'4'},
'd_cal_mlrefit'    : {'ML_LMLFF':'T', 'ML_MODE':'refit', 'ML_RCUT1':'10', 'ML_RCUT2':'6.0', 'ML_W1':'0.1', 'ML_MRB1':'15', 'ML_MRB2':'10', 
                      'ML_SION1':'0.5', 'ML_LMAX2':'3', 'ML_SIGW0':'1','ML_EPS_LO':'1E-11', 'ML_LSPARSDES': 'F' },
'd_cal_mlmd'       : {'ML_MODE':'run', 'ML_OUTBLOCK':'50', 'ML_OUTPUT_MODE':'0', 'IBRION':'0', 'TEBEG':'300', 'TEEND':'800', 
                      'MDALGO': '2', 'SMASS':'0', 'NBLOCK':'50', 'POTIM':'1', 'NSW ':'500000'}, 
#'d_cal_vdwoptB86b' : {'GGA':'MK','PARAM1':'0.1234','PARAM2':'1.0000','LUSE_VDW':'.TRUE.','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwoptB88'  : {'GGA':'BO','PARAM1':'0.1833333333','PARAM2':'0.2200000000','LUSE_VDW':'.TRUE.','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwoptPBE'  : {'GGA':'OR','LUSE_VDW':'.TRUE.','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwDF2'     : {'GGA':'ML','LUSE_VDW':'.TRUE.','Zab_vdW':'-1.8867','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwDF'      : {'GGA':'RE','LUSE_VDW':'.TRUE.','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwrevDF2'  : {'GGA':'MK','LUSE_VDW':'.TRUE.','PARAM1':'0.1234','PARAM2':'0.711357','Zab_vdW':'-1.8867','AGGAC':'0.0000','LASPH':'.TRUE.'},
#'d_cal_vdwSCAN'    : {'METAGGA':'SCAN','LUSE_VDW':'.TRUE.','BPARAM':'15.7','LASPH':'.TRUE.','ADDGRID':'.TRUE.'},
#'d_cal_vdwTS2'     : {'PREC': 'A', 'IVDW':'2'},
#'d_cal_vdwTS202'   : {'PREC': 'A', 'IVDW':'202'},
#'d_cal_vdwTS21'    : {'PREC': 'A', 'IVDW':'21'},
#'d_cal_vdwTS4'     : {'PREC': 'A', 'IVDW':'4'},
'd_cal_ispin'       : {'ISPIN':'2'},
'd_cal_pbe0'        : {'LHFCALC':'T','GGA':'PE','AEXX':'0.25','AGGAC':'1.0','ALDAC':'1.0'},
'd_cal_hse03'       : {'LHFCALC':'T','GGA':'PE','AEXX':'0.25','HFSCREEN':'0.3','AGGAC':'1.0','ALDAC':'1.0'},
'd_cal_hse06'       : {'LHFCALC':'T','GGA':'PE','AEXX':'0.25','HFSCREEN':'0.2','AGGAC':'1.0','ALDAC':'1.0'},
'd_cal_b3lyp'       : {'LHFCALC':'T','GGA':'B3','AEXX':'0.20','AGGAX':'0.72','AGGAC':'0.81','ALDAC':'0.19'},
'd_cal_hf'          : {'LHFCALC':'T','AEXX':'1.0','AGGAC':'0.0','ALDAC':'0.0'},
#'d_cal_yours        : {'item':'Parameter'},  # change 'yours' to the task name and add the parameters to the dictionary
}

tasks_recorded = [i.split('_')[2].lower() for i in tasks_incar.keys()]

## Functions to modify the parameters in INCAR file according to the POSCAR
def check_pos_car():
    poscar_paths = ['POSCAR', './01/POSCAR']
    ele_list = []
    for path in poscar_paths:
        if os.path.isfile(path):
            atoms = read(path, format='vasp')  # Using ASE to read POSCAR
            ele_list = atoms.get_chemical_symbols()  # Get the list of element symbols
            return True, ele_list
    # Executes only if no POSCAR is found
    print('POSCAR Not Found. Be careful about the D2, DFT+U parameters.')
    return False, []

### DFT + U 
u_value = {
    'Ag': 5.0, 'Cu': 5.0, 'Fe': 5.0, 'Ir': 5.0, 'Ni': 5.0, 'Pd': 5.0,
    'Pt': 5.0, 'Rh': 5.0, 'Co': 5.0, 'Ru': 5.0, 'Os': 5.0, 'Au': 5.0,
    'Ti': 5.1, 'Zn': 5.0, 'Sn': 5.0
}

j_value = {
    'Ag': 1.0, 'Cu': 1.0, 'Fe': 1.0, 'Ir': 1.0, 'Ni': 1.0, 'Pd': 1.0,
    'Pt': 1.0, 'Rh': 1.0, 'Co': 1.0, 'Ru': 1.0, 'Os': 1.0, 'Au': 1.0,
    'Ti': 1.0, 'Zn': 1.0, 'Sn': 1.0
}

def dftu_update(dftu):
    """Update DFT+U parameters based on POSCAR elements."""
    is_poscar_here, ele_list = check_pos_car()
    if not is_poscar_here:
        print("POSCAR not found. Skipping DFT+U parameter update.")
        return dftu

    unique_elements = []
    ldaul, u, j = [], [], []

    for element in ele_list:
        if element not in unique_elements:
            unique_elements.append(element)
            if element in u_value:
                ldaul.append(2)  # Apply DFT+U to this element
                u.append(u_value[element])
                j.append(j_value[element])
            else:
                ldaul.append(-1)  # No DFT+U applied
                u.append(0)
                j.append(0)

    # Update DFT+U parameters in the INCAR dictionary
    dftu.update({
        'LDAUL': '  '.join(map(str, ldaul)),
        'LDAUU': '  '.join(map(str, u)),
        'LDAUJ': '  '.join(map(str, j))
    })

    print(f"LDAUL set to: {ldaul}")
    print(f"LDAUU set to: {u}")
    print(f"LDAUJ set to: {j}")

    return dftu


def neb_update(neb):
    ''' Add the IMAGE numbers to NEB calculation'''
    folders = [f for f in os.listdir('.') if os.path.isdir(f)]
    images =  len([i  for i in folders if i.isdigit()]) - 2 
    neb.update({'IMAGES':str(images)})
    return neb

def freq_update(freq):
    del standard_incar['d_ncore']
    return standard_incar 


### SPIN & MAG
mag_value = { 
    'Ag': 0.0, 'Cu': 1.0, 'Fe': 3.0, 'Ir': 0.0, 'Ni': 1.0, 'Pd': 0.0,
    'Pt': 0.0, 'Rh': 0.0, 'Co': 2.0, 'Ru': 0.0, 'Os': 0.0, 'Au': 0.0,
    'Ti': 0.0, 'Zn': 0.0, 'Sn': 0.0, 'O': 0.0  # O  default magnetization 
}

def spin_update(ispin):
    try:
        atoms = read("POSCAR")
    except FileNotFoundError:
        print("POSCAR cannot be found. Exiting.")
        return

    symbols = atoms.get_chemical_symbols()  # Extract symbols in the order they appear
    element_counts = {}  # Dictionary to store element counts

    # Count occurrences of each element while preserving the order
    for symbol in symbols:
        if symbol in element_counts:
            element_counts[symbol] += 1
        else:
            element_counts[symbol] = 1

    magmom_list = []
    for symbol, count in element_counts.items():
        magmom_per_atom = mag_value.get(symbol, 0.0)
        magmom_list.append(f"{count}*{magmom_per_atom}")

    magmom_str = "  ".join(magmom_list)
    ispin.update({'MAGMOM': magmom_str})

    print(f"MAGMOM line updated: {magmom_str}")
    return ispin

def analyze_tasks(tasks):
    vdw_list = []
    unsupported_tasks = []

    for task in tasks:
        task_lower = task.lower()

        # Handle vdW and SCAN functional warnings
        if 'vdw' in task_lower:
            vdw_list.append(task)
        if 'scan' in task_lower:
            print("VASP 5.4.3 or higher is required for METAGGA = SCAN functional.")
            print("See: https://cms.mpi.univie.ac.at/wiki/index.php/METAGGA")

    # Check if multiple vdW types are set
    if len(vdw_list) >= 2:
        print("You cannot set more than one vdW type at the same time.")
        print(f"Detected vdW types: {' '.join(vdw_list)}")
        print("Please confirm your vdW type and rerun the command.")
        exit()

    dict_tasks = {}
    dict_task_groups = {}

    for task in tasks:
        if task in tasks_recorded:
            for k_task, v_task in tasks_incar.items():
                task_type = k_task.split('_')[2].lower()
                if task == task_type:
                    # Handle specific task updates
                    if task == 'dftu':
                        dftu_update(v_task)
                    elif task == 'neb':
                        neb_update(v_task)
                    elif task in ['vdwoptb86b', 'vdwoptb88', 'vdwdf2', 'vdwdf', 'vdwoptpbe', 'vdwrevdf2']:
                        print("Reminder: Copy vdw_kernel.bindat file to your job folder!\n" * 3)
                    elif task == 'ispin':
                        spin_update(v_task)
                        standard_incar['d_elec']['ISPIN'] = '2'
                    elif task == 'freq': 
                        freq_update(v_task)
                    # Update task dictionaries
                    dict_tasks.update(v_task)
                    dict_task_groups[k_task] = v_task
        else:
            unsupported_tasks.append(task)

    # Handle unsupported tasks
    if unsupported_tasks:
        print("The following tasks are not supported:\n")
        for task in unsupported_tasks:
            print(f"- {task}")
        print("\nSupported tasks:\n")
        print(" ".join(f"- {recorded_task}" for recorded_task in tasks_recorded))
        print("\nPlease use one of the supported tasks above and rerun the command.")
        exit()

    return dict_tasks, dict_task_groups


def generate_incar(standard_incar, dict_tasks, dict_task_groups):
    '''Creat INCAR file.''' 
    incar_out = open('INCAR', 'w')
    for k_std, v_std in standard_incar.items():
        ''' Write the standard incar parameters ''' 
        incar_out.write('%s\n' %(k_std.upper().replace('D_', '#')))
        for k, v in v_std.items():
            if k not in dict_tasks.keys():
                '''Write the parameters are not affected by the user's task'''
                incar_out.write('%s = %s \n' %(k, v))
        incar_out.write('\n')
    
    for k_task, v_task in dict_task_groups.items():
        ''' Write the specific parameters for the tasks'''
        incar_out.write('\n%s \n' %(k_task.upper().replace('D_', '#')))
        for k, v in v_task.items():
            incar_out.write('%s = %s \n' %(k, v))
    incar_out.close()        

def incar_alter(parameter, value):
    '''Change the parameter values, if the parameter is not in the INCAR, then add it. '''
    f = open('INCAR', 'r')
    lines = f.readlines()
    f.close()
    is_or_not = False 
    with open('INCAR') as myfile:
        if parameter in myfile.read():
            is_or_not = True
    if is_or_not:   
        f = open('INCAR', 'w')
        for line in lines:
            if parameter in line:
                f.write('%s = %s\n' %(parameter, value))
            else:
                f.write(line)
        f.close()    
    else:
        f = open('INCAR', 'a+')
        f.write('%s = %s\n' %(parameter, value))
        f.close()
        
def incar_delete(parameter):
    '''Delete the parameter from INCAR file '''
    f = open('INCAR', 'r')
    lines = f.readlines()
    f.close()
    f = open('INCAR', 'w')
    for line in lines:
        if parameter not in line:
            f.write(line)
    f.close()    

def set_ncore(ncore):
    '''NCORE/paralization can not be used for frequency calculations '''
    if not os.path.isfile('INCAR'):
        print('No INCAR found. Can not add the NCORE parameter to it.')
    else:    
        file_in = open('INCAR', 'r')
        lines = file_in.readlines()
        file_in.close()
        for line in lines:
            if 'IBRION' in line:
                value = line.rstrip().split('=')[1].strip()
                if value not in ['5', '6', '7', '8']:
                    incar_alter('NCORE', ncore)
                else:
                    incar_delete('NCORE')    

def similar(a, b):
    return SequenceMatcher(None, a, b).ratio()

tasks = [i.lower() for i in sys.argv[1:]]
tasks_not_recorded = []
for i in tasks:
    if i not in tasks_recorded:
        tasks_not_recorded.append(i)

if len(tasks_not_recorded) >= 1:
    suggestions = []
    for i in tasks_not_recorded:
        for j in tasks_recorded:
            if similar(i, j) >= 0.6:
                suggestions.append(f"- {i} is not supported. Did you mean: {j}?")

    if suggestions:
        print("\nThe following tasks are not supported but have close matches:\n")
        print("\n".join(suggestions))
    else:
        print("\nUnsupported tasks detected:\n")
        for task in tasks_not_recorded:
            print(f"- {task}")

    print("\nSupported task keywords:\n")
    print(" ".join(f"\n{task}" for task in tasks_recorded))
    print("\nPlease use one of the supported tasks above and run the command again.")
    exit()


#dict_tasks, dict_task_groups = analyze_tasks(tasks)
#generate_incar(standard_incar, dict_tasks, dict_task_groups)
