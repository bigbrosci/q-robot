#!/user/bin/env python3
# -*- coding: utf-8 -*-
from lattice import *
import os 

def print_thumb():
    print('''
          
From: https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html 
A rule of thumb for choosing the initial k-point sampling is, 
that the product, k x a, 
between the number of k-points, k, in any direction, 
and the length of the basis vector in this direction, a, 
should be:
    ka ~ 30 Å, for d band metals
    ka ~ 25 Å, for simple metals
    ka ~ 20 Å, for semiconductors
    ka ~ 15 Å, for insulators
    
''')

is_poscar_here = True
if os.path.isfile('POSCAR'):
    lines_poscar = read_car('POSCAR')[0]
    la, lb, lc = get_abc(lines_poscar)[0:3]
else: 
    is_poscar_here = False    
    
    
def generate_kpoints(file_out = 'KPOINTS'):
    if is_poscar_here: 
        knum  = 40       
        k_a =  int(round(knum/la,0))
        k_b =  int(round(knum/lb,0))
        k_c =  int(round(knum/lc,0))
    else: 
        k_a, k_b, k_c = [3, 3, 1]
    kpoints = open(file_out, 'w')
    kpoints.write('K-POINTS\n0\nGamma\n') 
    kpoints.write('%s %s %s\n0 0 0' %(k_a, k_b, k_c) )
    kpoints.close()
    print('\nGamma Centered KPOINTS has been Generated: %s %s %s' %(k_a, k_b, k_c) )

def read_kpoints(file_read = 'KPOINTS'):
    file_in = open(file_read, 'r')
    lines = file_in.readlines()
    file_in.close()
    
    k_a, k_b, k_c = [int(i) for i in lines[3].strip().split()]
    print('\n K:   \t %4s   %4s   %4s\n\n' %(k_a, k_b, k_c))
    if is_poscar_here:
        ka = [k_a * la, k_b * lb, k_c * lc]
        print('a:   \t %.3f  %.3f  %.3f\n' %(la, lb, lc))
        print('K*a: \t %.3f  %.3f  %.3f\n' %(ka[0], ka[1], ka[2]))
        print_or_not = False 
        for i in ka: 
            if i < 20: 
                print_or_not = True
        if print_or_not:        
            print('Too small K*a value is found\n' * 3)
            print_thumb()
    else:
        print('%s\n' %('%' * 40))
        print('\nWARNING!!! No POSCAR in current folder!!\n' * 2 )
        print('%s\n' %('%' * 40))    
        print_thumb()

def generate_kpoints_by_hands(k_a, k_b, k_c,file_out = 'KPOINTS', ):
    k_a, k_b, k_c = [int(k_a),int(k_b), int(k_c)]
    kpoints = open(file_out, 'w')
    kpoints.write('K-POINTS Generated By Q-Robot\n0\nGamma\n') 
    kpoints.write('%s %s %s\n0 0 0' %(k_a, k_b, k_c) )
    kpoints.close()
    print('\nGamma Centered KPOINTS have been Generated: %s %s %s\n' %(k_a, k_b, k_c) ) 
    if os.path.isfile('POSCAR'):
        read_kpoints(file_out)
        
##### For band calculations #####

def read_kpoints_band(kfile='KPOINTS'):
    f =  open (kfile, 'r')
    lines_k = f.readlines()
    f.close()
    num_lines_k = len(lines_k) 
    num_start = 4 
    k_list = []
    for i in range(num_start,num_lines_k):
        num_ele = lines_k[i].rstrip().split() 
        if len(num_ele) > 2: 
            k_list.append(i)
    num_pairs = (max(k_list) -5 )/3 + 1 
    return lines_k, num_pairs 

def get_points(a, b, num_points):
    a = float(a) 
    b = float(b)
    c = num_points
    list_points = []
    for i in range(0, c):
         list_points.append(a + (b-a)/(c-1) * i)
    return list_points

def get_one_pair_kpoint(lines_k, num_pair):
    num_points = int(lines_k[1].split()[0]) 
    num_pair = int(num_pair)
    num_points = int(num_points)
    lines_k_start =  num_pair * 3 + 4 
    lines_k_end   =  num_pair * 3 + 5
    x_s, y_s, z_s = lines_k[lines_k_start].split()[0:3]
    x_e, y_e, z_e = lines_k[lines_k_end].split()[0:3]
    x_list = get_points(x_s, x_e, num_points)
    y_list = get_points(y_s, y_e, num_points)
    z_list = get_points(z_s, z_e, num_points)
    
    return x_list, y_list, z_list        

def get_k_add_lines(lines_k, num_pairs):
    num_points = int(lines_k[1].split()[0]) 
    lines_k_add = []
    for i in range(0, num_pairs):
        data = get_one_pair_kpoint(lines_k, i)
        for j in range(0, num_points):
            x_cor = data[0][j]
            y_cor = data[1][j]
            z_cor = data[2][j]
            line_ele_k = '%.8f  %.8f  %.8f \n' %(x_cor, y_cor, z_cor) 
            lines_k_add.append(line_ele_k)
    return lines_k_add      

def read_ibzkpt(file_in = 'IBZKPT'):
    f = open('IBZKPT', 'r')
    lines_ib = f.readlines()
    f.close() 
    num_points_ib = int(lines_ib[1].split()[0])
    num_lines_ib = len(lines_ib)
    return lines_ib, num_lines_ib, num_points_ib  

def read_k_add():
    f_k_add = open('k_add', 'r')
    lines_k_add = f_k_add.readlines()
    f_k_add.close()
    return lines_k_add 

def get_distance(a,b):
    a = np.array(list(float(i) for i in a)) 
    b = np.array(list(float(i) for i in b)) 
    vector = b-a 
    distance = np.linalg.norm(vector)
    return distance

def k_distance(): 
    lines_k_add = read_k_add()
    dis = 0 
    k_d = []
    k_d.append(dis)
    for i in range(1, len(lines_k_add)):
        a = lines_k_add[i-1].strip().split()
        b = lines_k_add[i].strip().split()
        dis_ab = get_distance(a,b)
        dis = dis + dis_ab
        k_d.append(dis)
    return k_d           
